var models = require('model/models');
var errors = require('lib/errors');

function success(successCallback, next) {
    return function(err, result) {
        if (err) {
            next(err);
        } else {
            successCallback(result);
        }
    };
}

var Controller = module.exports = function() {

};

Controller.prototype.createToken = function(req, res, next) {
    if (req.body.grant_type !== 'authorization_code') {
        next(new errors.ApiError('unsupported_grant_type'));
    } else {
        var accessTokenRepository = this.get('repository.access_token');
        var blacklistRepository = this.get('repository.blacklist');
        this.get('repository.code').load(req.body.code, function(err, code) {
            if (err) {
                next(err);
            } else {
                if (code.get('redirectUri') !== req.body.redirect_uri) {
                    next(new errors.ApiError(
                        'invalid_grant',
                        'redirect_uri does not match with the one used in redirect'
                    ));
                } else if (parseInt(code.get('credentialsId')) !== parseInt(req.credentials.get('id'))) {
                    next(new errors.ApiError(
                        'invalid_grant',
                        'this code was issued to another client'
                    ));
                } else if (code.get('expires').getTime() <= new Date().getTime()) {
                    next(new errors.ApiError(
                        'invalid_grant',
                        'code expired'
                    ));
                } else {
                    blacklistRepository.isCodeUsed(code.get('id'), success(function(used) {
                        if (used) {
                            blacklistRepository.revokeCode(code.get('id'), function(err) {
                                next(new errors.ApiError(
                                    'invalid_grant',
                                    'code already used'
                                ));
                            });
                        } else {
                            var expireAt = new Date().getTime() / 1000 + 3600;
                            blacklistRepository.useCode(code.get('id'), expireAt, success(function() {
                                var accessToken = new models.AccessToken({
                                    expires: expireAt,
                                    credentialsId: code.get('credentialsId'),
                                    codeId: code.get('id'),
                                    scopes: code.get('scopes'),
                                    userId: code.get('userId')
                                });
                                accessTokenRepository.save(accessToken, function(err, accessToken) {
                                    if (err) {
                                        next(err);
                                    } else {
                                        res.send(JSON.stringify(accessToken.toJSON({includePrivate: true})));
                                    }
                                });
                            }, next));
                        }
                    }, next));
                }

            }
        });
    }
};
Controller.prototype.createClient = function(req, res, next) {
    var passwordRepository = this.get('repository.application_password'),
        credentialsRepository = this.get('repository.application_credentials'),
        signerRegistry = this.get('signer_registry'),
        algorithm = this.get('application_credentials_algorithm');

    passwordRepository.load(req.body.application_id, success(function(password) {
        if (password.get('secret') !== req.body.application_secret) {
            next(new errors.ApiError(
                'invalid_grant',
                'password is not correct'
            ));
        } else {
            var signer = signerRegistry.get(algorithm);
            var credentials = new models.ApplicationCredentials({
                passwordId: password.get('id'),
                signatureCredentials: {
                    mac_algorithm: algorithm,
                    type: signer.getCredentialsType()
                }
            });
            signer.prepareForSave(credentials.get('signatureCredentials'), success(function() {
                credentialsRepository.save(credentials, success(function(credentials) {
                    res.send(JSON.stringify(credentials.get('signatureCredentials').toJSON({includePrivate: true})));
                }, next));
            }, next));
        }
    }, next));
};

Controller.prototype.removeClient = function(req, res, next) {
    this.get('repository.login_credentials').remove(req.credentials.get('id'), function(err) {
        if (err) {
            next(err);
        } else {
            res.send(JSON.stringify(true));
        }
    });
};