var crypto = require('crypto');
var models = require('model/models');
var errors = require('lib/errors');
var _ = require('lodash')._;

var Controller = module.exports = function(signer) {
    this.signer = signer;
};

Controller.prototype.proxy = function(req, res, next) {
    var http = require('http');
    var headers = req.headers;
    var credentials = req.credentials;
    var token = req.token;

    if (credentials) {
        var auth = new Buffer(JSON.stringify({
            type: credentials.get('type'),
            id: credentials.getRemoteId(),
            credentials_id: credentials.get('id'),
            access_token: token ? {user_id: token.get('userId'), scopes: token.get('scopes')} : null
        })).toString('base64');
        var signature = this.signer.sign(auth);


        headers['x-oauth-commerce-proxy-authorization'] = 'Auth="' + auth + '", Signature="' + signature + '"';
    } else {
        delete headers['x-oauth-commerce-proxy-authorization'];
    }

    //headers.host = headers.host.replace(/:[^:]+$/, '');

    var requestOptions = {
        hostname: 'localhost',
        path: req.url,
        method: req.method,
        headers: headers,
        port: 8000
    };

    //console.log('proxy', requestOptions);

    var accessTokenRepository = this.get('repository.access_token');

    var myReq = http.request(requestOptions, function (myRes) {
        if (typeof myRes.headers['x-oauth-commerce-proxy-special-response'] !== 'undefined') {
            var responseType = myRes.headers['x-oauth-commerce-proxy-special-response'];
            delete myRes.headers['x-oauth-commerce-proxy-special-response'];
            if (responseType === 'access_token') {
                var body = '';
                myRes.on('data', function(chunk) {
                    body += chunk;
                });
                myRes.on('end', function() {
                    var accessToken = new models.AccessToken(JSON.parse(body));
                    accessTokenRepository.save(accessToken, function(err, accessToken) {
                        if (err) return next(err);
                        res.headers = myRes.headers;
                        res.statusCode = myRes.statusCode;
                        res.send(accessToken.toJSON({includePrivate: true}));
                    });
                });

            } else {
                next(new errors.ApiError(
                    'invalid_request',
                    'Unknown response type'
                ));
            }
        } else {
            res.writeHead(myRes.statusCode, myRes.headers);
            myRes.on('error', function (err) {
                next(err);
            });
            myRes.pipe(res);
        }
    });

    myReq.on('error', function (err) {
        next(err);
    });
    myReq.write(req.rawBody);
    myReq.end();
};