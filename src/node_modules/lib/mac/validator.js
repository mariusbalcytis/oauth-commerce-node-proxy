var qs = require('qs');
var crypto = require('crypto');
var async = require('async');
var DeferredCallback = require('lib/deferredCallback.js');
var errors = require('lib/errors');

var Validator = module.exports = function(signerRegistry, timestampManager, blacklistManager, tokenManager, credentialsManager) {
    this.signerRegistry = signerRegistry;
    this.timestampManager = timestampManager;
    this.blacklistManager = blacklistManager;
    this.tokenManager = tokenManager;
    this.credentialsManager = credentialsManager;
};


Validator.prototype.validateRequest = function(req, macParams, credentialsId, callback) {
    var method = req.method,
        url = req.url,
        host = req.headers.host,
        protocol = req.protocol,
        signerRegistry = this.signerRegistry,
        blacklistManager = this.blacklistManager,
        timestampManager = this.timestampManager,
        credentialsManager = this.credentialsManager,
        tokenManager = this.tokenManager;

    var hostParts = host.split(':'), port;
    if (hostParts.length === 2) {
        host = hostParts[0];
        port = hostParts[1];
    } else {
        port = protocol === 'https' ? '443' : '80';
    }

    function getNormalizedRequestString(ext) {
        return [
            macParams.ts,
            macParams.nonce,
            method,
            url,
            host,
            port,
            ext
        ].join("\x0a") + "\x0a";
    }

    var extParams = qs.parse(macParams.ext);
    if (!extParams.bodyhash) {
        callback(new errors.ApiError('unauthorized', 'Missing bodyhash parameter in ext field'));
    }

    var bodyHashDeferredMap = {
        'sha256': new DeferredCallback(),
        'sha512': new DeferredCallback()
    };
    getBodyHash(req, 'sha256', bodyHashDeferredMap['sha256'].callback);
    getBodyHash(req, 'sha512', bodyHashDeferredMap['sha512'].callback);

    credentialsManager.load(credentialsId, function(err, credentials) {
        if (err) {
            callback(err);
        } else {
            var signatureCredentials = credentials.get('signatureCredentials');
            var signer = signerRegistry.get(signatureCredentials.get('algorithm'));
            var macValid = signer.checkSign(
                signatureCredentials,
                macParams.mac,
                getNormalizedRequestString(macParams.ext)
            );
            var bodyHashDeferred = bodyHashDeferredMap[signer.getHashAlgorithm()];

            blacklistManager.isNonceUsed(macParams.id, macParams.nonce, function(err, nonceUsed) {
                if (err) {
                    callback(err);
                    return;
                }

                if (!macValid) {
                    callback(new errors.ApiError('unauthorized', 'Invalid MAC value'));
                } else if (nonceUsed) {
                    callback(new errors.ApiError('unauthorized', 'Nonce already used'));
                } else {
                    async.parallel({
                        timestampValid: isTimestampValid(macParams.id, macParams.ts),
                        bodyHash: bodyHashDeferred.done(),
                        token: getToken(extParams),
                        nonceUsed: useNonce(macParams.id, macParams.nonce)
                    }, function(err, result) {
                        if (err) {
                            callback(err);
                        } else if (!result.timestampValid) {
                            callback(new errors.ApiError('unauthorized', 'Timestamp value is invalid'));
                        } else if (result.bodyHash !== extParams.bodyhash) {
                            callback(new errors.ApiError('unauthorized', 'Bodyhash in ext is invalid'));
                        } else {
                            callback(null, credentials, result.token);
                        }
                    });
                }
            });
        }
    });

    function getBodyHash(req, algorithm, callback) {
        var bodyHash = crypto.createHash(algorithm);
        req.setEncoding('utf8');
        req.on('data', function(chunk) {
            bodyHash.update(chunk);
        });
        req.on('end', function() {
            var bodyHashValue = bodyHash.digest('base64');
            callback(null, bodyHashValue);
        });
    }

    function useNonce(macId, nonce) {
        return function(callback) {
            blacklistManager.useNonce(macId, nonce, 306, callback);
        }
    }


    function getToken(extParams) {
        return function(callback) {
            if (extParams.access_token_id && extParams.access_token_mac) {
                tokenManager.load(extParams.access_token_id, function(err, token) {
                    if (err) {
                        callback(err);
                    } else {
                        blacklistManager.isCodeRevoked(token.get('codeId'), function(err, revoked) {
                            if (err) {
                                callback(err);
                            } else if (revoked) {
                                callback(new errors.ApiError('unauthorized', 'This token was revoked'));
                            } else {
                                var signatureCredentials = token.get('signatureCredentials');
                                var signResult = signerRegistry.get(signatureCredentials.get('algorithm')).checkSign(
                                    signatureCredentials,
                                    extParams.access_token_mac,
                                    getNormalizedRequestString('')
                                );
                                if (signResult) {
                                    callback(null, token);
                                } else {
                                    callback(new errors.ApiError(
                                        'unauthorized',
                                        'Invalid access token MAC value in ext parameter'
                                    ));
                                }
                            }
                        });
                    }
                });
            } else {
                callback();
            }
        }
    }

    function isTimestampValid(macId, ts) {
        return function(callback) {
            timestampManager.load(macId, function(err, timestampDiff) {
                if (err) {
                    callback(err);
                } else if (timestampDiff === null) {
                    callback(null, true);
                } else {
                    callback(null, timestampValid(timestampDiff + ts));
                }
            });
        }
    }

    function timestampValid(adjustedTimestamp) {
        var diff = new Date().getSeconds() - adjustedTimestamp;
        return diff >= -5 && diff < 300;
    }

};


